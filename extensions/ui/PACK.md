---
name: "@rune/ui"
description: Frontend UI patterns — design systems, component architecture, accessibility audits, and animation patterns.
metadata:
  author: runedev
  version: "0.1.0"
  layer: L4
  price: "$12"
  target: Frontend developers
---

# @rune/ui

## Purpose

Frontend development accumulates invisible debt: ad-hoc color variables, prop-drilled components, untested accessibility, and janky animations. This pack addresses all four systematically. Each skill targets a distinct layer of frontend quality — token consistency, component composability, WCAG compliance, and motion polish — so you can audit and improve any layer independently or run all four as a full UI health check.

## Triggers

- Auto-trigger: when `*.tsx`, `*.svelte`, `*.vue`, CSS/Tailwind files detected in project
- `/rune design-system` — generate or enforce design tokens
- `/rune component-patterns` — refactor component architecture
- `/rune a11y-audit` — run accessibility audit
- `/rune animation-patterns` — add or refine motion design
- Called by `cook` (L1) when frontend task is detected
- Called by `review` (L2) when UI code is under review

## Skills Included

### design-system

Generate and enforce design system tokens — colors, typography, spacing, shadows, border radius. Detects existing ad-hoc values and consolidates them into a structured token file.

#### Workflow

**Step 1 — Detect existing tokens**
Use Grep to scan for hardcoded color values (`#[0-9a-fA-F]{3,6}`, `rgb(`, `hsl(`), spacing (`px`, `rem`), and font sizes across all CSS, Tailwind config, and component files. Build an inventory of values in use.

**Step 2 — Generate token file**
From the inventory, produce a CSS custom properties file (or `tailwind.config` theme extension). Group tokens into semantic layers: primitive → semantic → component. Flag duplicates and near-duplicates (e.g., `#1a1a2e` vs `#1a1a2f`).

**Step 3 — Enforce consistency**
Re-run Grep after token file is written. Any hardcoded value that has a matching token is flagged as a violation. Output a replacement diff for each violation.

#### Example

```css
/* tokens.css — generated by design-system skill */
:root {
  /* Primitive */
  --color-indigo-600: #4f46e5;
  --color-slate-900: #0f172a;
  --space-4: 1rem;
  --radius-md: 0.5rem;

  /* Semantic */
  --bg-base: var(--color-slate-900);
  --color-primary: var(--color-indigo-600);
  --border-radius-card: var(--radius-md);
}
```

---

### component-patterns

Component architecture patterns — compound components, render props, composition, slots. Detects prop-heavy components and guides refactoring toward composable, maintainable architectures.

#### Workflow

**Step 1 — Detect prop-heavy components**
Use Grep to find component signatures with more than 8 props (`interface \w+Props \{` then count fields, or scan function parameter lists). Read each flagged file to understand the component's responsibilities.

**Step 2 — Classify and suggest pattern**
For each flagged component, classify by smell: boolean-flag hell → compound component; render logic branching → render props or slots; deeply nested data → context + provider. Output a refactor plan with the specific pattern to apply.

**Step 3 — Emit refactored scaffold**
Write the refactored component skeleton following the compound component pattern. Do not overwrite the original — emit to a `*.refactored.tsx` file for review.

#### Example

```tsx
// BEFORE: prop-heavy (9 props, hard to extend)
<Modal title="..." open footer actions size variant onClose onConfirm loading />

// AFTER: compound component pattern
<Modal open onClose={handleClose}>
  <Modal.Header>Confirm Action</Modal.Header>
  <Modal.Body>Are you sure?</Modal.Body>
  <Modal.Footer>
    <Button variant="ghost" onClick={handleClose}>Cancel</Button>
    <Button variant="primary" loading={isLoading} onClick={handleConfirm}>
      Confirm
    </Button>
  </Modal.Footer>
</Modal>
```

---

### a11y-audit

Accessibility audit beyond automated tools. Checks WCAG 2.1 AA compliance — focus management, screen reader compatibility, color contrast, ARIA patterns, and keyboard navigation.

#### Workflow

**Step 1 — Automated scan**
Run `Bash: npx axe-core-cli <url> --reporter json` to capture all automated violations. Parse the JSON output and group by impact: critical → serious → moderate → minor.

**Step 2 — Manual WCAG 2.1 AA review**
Use Grep to find `onClick` on non-button elements (missing keyboard support), `<img` without `alt`, `aria-label` absence on icon-only buttons, and `outline: none` without a focus-visible replacement. Read flagged files and annotate each violation with the WCAG criterion it breaks.

**Step 3 — Emit audit report**
Produce a structured report: automated violations (count by impact), manual violations (file + line + fix), contrast ratios for brand colors (pass/fail at AA). Include a prioritized fix list.

#### Example

```tsx
// VIOLATION: icon button with no accessible name
<button onClick={handleClose}>
  <XIcon />
</button>

// FIX: add aria-label; icon is decorative
<button onClick={handleClose} aria-label="Close dialog">
  <XIcon aria-hidden="true" />
</button>

// VIOLATION: div acting as button (no keyboard, no role)
<div onClick={handleSubmit}>Submit</div>

// FIX: use semantic element
<button type="button" onClick={handleSubmit}>Submit</button>
```

---

### animation-patterns

Motion design patterns — micro-interactions, page transitions, scroll animations, loading states. Applies CSS transitions, Framer Motion, or GSAP based on project stack. Always respects `prefers-reduced-motion`.

#### Workflow

**Step 1 — Detect interaction points**
Use Grep to find hover handlers (`onMouseEnter`, `:hover`), route changes (Next.js `useRouter`, SvelteKit `goto`), and loading states (`isLoading`, `isPending`). Read component files to understand where motion can add feedback or polish.

**Step 2 — Apply micro-interactions**
For each interaction point, select the appropriate pattern: hover → scale + shadow lift; button click → press-down (scale 0.97); data load → skeleton pulse then fade-in; route change → slide or fade transition. Emit the updated component with motion classes or Framer Motion variants.

**Step 3 — Audit reduced-motion compliance**
Use Grep to find every animation/transition declaration. Verify each is wrapped in a `prefers-reduced-motion: no-preference` media query or uses Framer Motion's `useReducedMotion()` hook. Flag any that are not.

#### Example

```tsx
// Tailwind micro-interaction with reduced-motion respect
<button
  className="
    transform transition-all duration-200 ease-out
    hover:scale-105 hover:shadow-md
    active:scale-95
    motion-reduce:transform-none motion-reduce:transition-none
  "
>
  Confirm
</button>

// Framer Motion with reduced-motion hook
const prefersReduced = useReducedMotion()

<motion.div
  initial={{ opacity: 0, y: prefersReduced ? 0 : 16 }}
  animate={{ opacity: 1, y: 0 }}
  transition={{ duration: prefersReduced ? 0 : 0.25 }}
/>
```

---

## Connections

```
Calls → asset-creator (L3): generate design assets (icons, illustrations)
Called By ← review (L2): when UI code is being reviewed
Called By ← cook (L1): when frontend task detected
Called By ← launch (L1): pre-launch UI quality gate
```

## Tech Stack Support

| Framework | Styling | Components |
|-----------|---------|------------|
| React 19 | TailwindCSS 4 | shadcn/ui |
| Next.js 16 | CSS Modules | Radix UI |
| SvelteKit 5 | CSS Custom Props | Custom |
| Vue 3 | TailwindCSS 4 | Headless UI |

## Constraints

1. MUST respect `prefers-reduced-motion` on every animation — no exceptions.
2. MUST NOT overwrite original component files during refactor — emit to `*.refactored.tsx` or provide a diff.
3. MUST target WCAG 2.1 AA as the minimum bar for all a11y recommendations (AAA where feasible).
4. MUST use project's existing stack (detect from `package.json`) before suggesting new dependencies.

## Sharp Edges

| Failure Mode | Severity | Mitigation |
|---|---|---|
| Token generation produces semantic tokens without primitives, causing theme switching to break | HIGH | Always emit 3-layer token structure: primitive → semantic → component |
| Compound component refactor breaks controlled state (open/value props lost) | HIGH | Audit for controlled vs uncontrolled patterns before emitting scaffold |
| axe-core misses ARIA live region issues and dynamic content violations | MEDIUM | Supplement automated scan with manual Grep for `setState`/store updates that modify visible content |
| Framer Motion animations ship without `useReducedMotion` check | HIGH | Grep for `motion.` usage post-edit; flag any missing the hook |
| Design token enforcement flags third-party library hardcoded values | LOW | Scope Grep to `src/` only; exclude `node_modules` and generated files |

## Done When

- Token file generated and all hardcoded values replaced or flagged with diffs
- Component refactor scaffold emitted; original files untouched
- Axe-core scan shows zero critical/serious violations; manual review complete with prioritized fix list
- All animations pass `prefers-reduced-motion` audit
- Structured report emitted for each skill invoked

## Cost Profile

~8,000–14,000 tokens per full pack run (all 4 skills). Individual skill: ~2,000–4,000 tokens. Sonnet default. Use haiku for token detection scan (Step 1 of each skill); escalate to sonnet for refactor generation and report writing.
